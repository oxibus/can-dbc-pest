//! DBC (Database CAN) file parser grammar
//!
//! This grammar parses DBC files used for CAN bus communication definitions.
//! DBC files contain message definitions, signal specifications, node information,
//! and various attributes for automotive and industrial CAN networks.

/// Main DBC file structure
file = { SOI ~ (line)* ~ EOI }

/// A single line in the DBC file - can be various types of statements or empty
line = _{
    (
        version
        | new_symbols
        | bit_timing
        | nodes
        | message
        | signal
        | comment
        | attr_def
        | attr_value
        | value_table
        | value_table_def
        | signal_group
        | signal_value_type
        | bo_tx_bu
        | ba_def_rel
        | ba_rel
        | ba_def_def_rel
        | ba_def_def
        | sg_mul_val
        | environment_variable
        | envvar_data
        | NEWLINE
    )
}

// ============================================================================
// WHITESPACE AND COMMENTS
// ============================================================================

/// Implicit whitespace - spaces and tabs
WHITESPACE = _{ " " | "\t" }

/// Line comments starting with //
COMMENT = _{ "//" ~ (!NEWLINE ~ ANY)* }

// ============================================================================
// BASIC TOKENS
// ============================================================================

/// Integer numbers (positive and negative, including scientific notation)
int = @{ ("+" | "-")? ~ ASCII_DIGIT+ }

/// Unsigned Integer
uint = @{ ASCII_DIGIT+ }

/// CAN ID (unsigned integer)
message_id = @{ ASCII_DIGIT+ }

/// A number which can be integer or floating point
number = @{ ("+" | "-")? ~ (ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? | "." ~ ASCII_DIGIT+) ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }

/// Minimum and maximum values
min_max = { "[" ~ minimum ~ "|" ~ maximum ~ "]" }
minimum = @{ number }
maximum = @{ number }

/// String literals in double quotes
quoted_str = @{ quote ~ string ~ quote }
unit = @{ quoted_str }
attribute_name = @{ quoted_str }

/// String literal content, without the surrounding quotes
string = ${ char* }
char = _{ "\\\"" | !quote ~ ANY }
quote = _{ "\"" }

/// Identifiers (node names, message names, signal names, etc.)
ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

/// Extended Identifiers (same as ident, but also allowing leading digits)
ident_ext = @{ (ASCII_ALPHANUMERIC | "_")+ }
signal_name = @{ ident_ext }
num_str_value = _{ number | quoted_str }

env_var = { env_literal ~ env_var_name }
env_var_name = @{ ident }
env_literal = _{ "EV_" }

node_var = { node_literal ~ node_name }
node_name = @{ ident_ext }
node_literal = _{ "BU_" }

msg_var = { msg_literal ~ message_id }
msg_literal = _{ "BO_" }

signal_var = { signal_literal ~ message_id ~ ident }
signal_literal = _{ "SG_" }

// ============================================================================
// DBC FILE SECTIONS
// ============================================================================

/// Version identifier of the DBC file.
///
/// Format: `VERSION "string"`
version = { "VERSION" ~ quoted_str ~ NEWLINE }

/// New Symbol section: NS_ : symbol1 symbol2 ...
/// The spaces and comments are explicit because each symbol must be indented on new lines.
/// The indented lines are what tells us that they are part of the new_symbols section.
new_symbols = ${
    "NS_" ~ WHITESPACE* ~ ":" ~ WHITESPACE* ~ (ident ~ WHITESPACE*)* ~ COMMENT* ~
    (NEWLINE ~ (WHITESPACE+ ~ ident)* ~ WHITESPACE* ~ COMMENT*)* ~
    NEWLINE
}

/// The bit timing section defines the baud-rate and the settings of the BTR registers of
/// the network. This section is obsolete and not used anymore. Nevertheless, the
/// keyword `BS_` must appear in the DBC file.
///
/// Format: `bit_timing = BS_: [baud_rate : BTR1 , BTR2 ] ;`
bit_timing = { "BS_" ~ ":" ~ (uint ~ ":" ~ uint ~ "," ~ uint)? ~ NEWLINE }

/// Node definition: BU_: node1 node2 node3 ...
/// Just like new_symbols, the spaces and comments are explicit because each node can be either on the same line or
/// space-indented on new lines.
nodes = ${
    node_literal ~ WHITESPACE* ~ ":" ~ WHITESPACE* ~ (node_name ~ WHITESPACE*)* ~ COMMENT* ~
    (NEWLINE ~ (WHITESPACE+ ~ node_name)* ~ WHITESPACE* ~ COMMENT*)* ~
    NEWLINE
}

/// Message definition: BO_ message_id message_name: message_size transmitter
message = { msg_var ~ message_name ~ ":" ~ message_size ~ transmitter }
message_name = @{ ident_ext }
message_size = @{ int }
transmitter = @{ ident }

/// Signal definition: SG_ signal_name : start_bit|signal_size@byte_order+/- (factor,offset) [min|max] "unit" receiver
///
/// The message's signal section lists all signals placed on the message, their position
/// in the message's data field and their properties.
///
/// ```text
/// signal = 'SG_' signal_name multiplexer_indicator ':' start_bit '|'
/// signal_size '@' byte_order value_type '(' factor ',' offset ')'
/// '[' minimum '|' maximum ']' unit receiver {',' receiver} ;
/// signal_name = DBC_identifier ;
/// multiplexer_indicator = ' ' | [m multiplexer_switch_value] [M] ;
/// start_bit = unsigned_integer ;
/// signal_size = unsigned_integer ;
/// byte_order = '0' | '1' ; (* 0=big endian, 1=little endian *)
/// value_type = '+' | '-' ; (* +=unsigned, -=signed *)
/// factor = double ;
/// offset = double ;
/// minimum = double ;
/// maximum = double ;
/// unit = char_string ;
/// receiver = node_name | 'Vector__XXX' ;
/// ```
///
/// Signal definition.
/// Format: `SG_ <SignalName> [M|m<MultiplexerIdentifier>] : <StartBit>|<Length>@<Endianness><Signed> (<Factor>,<Offset>) [<Min>|<Max>] "[Unit]" [ReceivingNodes]`
/// Length in bits.
/// Signed: + = unsigned; - = signed
/// Endianness: 1 = little-endian, Intel; 0 = big-endian, Motorola
/// M: If M than this signals contains a multiplexer identifier.
/// `MultiplexerIdentifier`: Signal definition is only used if the value of the multiplexer signal equals this value.

signal = {
    signal_literal ~ signal_name ~ multiplexer_indicator? ~ ":" ~
    (
        start_bit ~ ("|" ~ signal_size)? ~ "@" ~
        ( big_endian | little_endian ) ~  // 0 | 1
        ( signed_type | unsigned_type ) ~ // - | +
        "(" ~ factor ~ "," ~ offset ~ ")" ~
        min_max ~
        unit ~ node_name ~ ("," ~ node_name)*
    )
}

multiplexer_indicator = @{ "M" | ("m" ~ (multiplexer_id ~ "M"?)? ) }
start_bit = @{ int }
signal_size = @{ int }
big_endian = @{ "0" }
little_endian = @{ "1" }
signed_type = @{ "-" }
unsigned_type = @{ "+" }
factor = @{ number }
offset = @{ number }

/// Comment definitions: CM_ [BU_|BO_|SG_|EV_] object_name "comment_text";
///
/// The comment section contains the object comments. For each object having a
/// comment, an entry with the object's type identification is defined in this section.
///
/// ```text
/// comments = {comment} ;
/// comment = 'CM_' (char_string |
/// 'BU_' node_name char_string |
/// 'BO_' message_id char_string |
/// 'SG_' message_id signal_name char_string |
/// 'EV_' env_var_name char_string)
/// ';' ;
/// ```
comment = {
    "CM_" ~ (
        (signal_literal ~ message_id ~ signal_name? ~ quoted_str)
         | (msg_var ~ quoted_str)
         | (node_var ~ quoted_str)
         | (env_var ~ quoted_str)
         | quoted_str
         | (message_id ~ quoted_str)  // message_id + string does not seem to have description above
    ) ~ ";"?
}

/// Attribute definition: BA_DEF_ [object_type] attribute_name attribute_type [min max];
///
/// ```text
/// BA_DEF_  "FloatAttribute" FLOAT 0 50.5;
/// BA_DEF_ BU_  "BUIntAttribute" INT 0 100;
/// BA_DEF_ BO_  "BOStringAttribute" STRING ;
/// BA_DEF_ BO_  "BOStringAttribute" STRING ;
/// BA_DEF_ SG_  "SGEnumAttribute" ENUM  "Val0","Val1","Val2";
/// BA_DEF_ SG_  "SGEnumAttribute" ENUM  "Val0","Val1","Val2";
/// BA_DEF_ EV_  "RWEnvVar_wData_Val" INT 0 10;
/// BA_DEF_ EV_  "GlobalEnvVar_Val" HEX 256 320;
/// ```
attr_def = { "BA_DEF_" ~ (object_type ~ ident?)? ~ attribute_name ~ attribute_type ~ ";" }

object_type = { node_literal | msg_literal | signal_literal | env_literal }

attribute_type = _{
    attribute_type_int
    | attribute_type_hex
    | attribute_type_float
    | attribute_type_string
    | attribute_type_enum
}
attribute_type_int = { "INT" ~ minimum ~ maximum }
attribute_type_hex = { "HEX" ~ minimum ~ maximum }
attribute_type_float = { "FLOAT" ~ minimum ~ maximum }
attribute_type_string = { "STRING" }
attribute_type_enum = { "ENUM" ~ quoted_str ~ ("," ~ quoted_str)* }


/// Attribute value: BA_ attribute_name [object_type] object_name value;
attr_value = {
    "BA_" ~ attribute_name ~ (
        node_var
        | msg_var
        | signal_var
        | env_var
    )? ~ num_str_value ~ ";"
}


/// Value table definition: VAL_ message_id signal_name value1 "description1" value2 "description2" ... ;
///
/// ```text
/// VAL_ RWEnvVar_wData 2 "Value2" 1 "Value1" 0 "Value0" ;
/// ```
value_table_def = { "VAL_" ~ message_id? ~ signal_name ~ table_value_description* ~ ";"? }

/// Value table: VAL_TABLE_ table_name value1 "description1" value2 "description2" ... ;
///
/// The value table section defines the global value tables. The value descriptions in
/// value tables define value encodings for signal raw values. In commonly used DBC
/// files the global value tables aren't used, but the value descriptions are defined for
/// each signal independently.
///
/// ```text
/// value_tables = {value_table} ;
/// value_table = 'VAL_TABLE_' value_table_name {value_description} ';' ;
/// value_table_name = DBC_identifier ;
/// ```
///
/// Format: `VAL_TABLE_ <value_table_name> <value_description>;`
///
/// `value_description`: List of `IntValue "StringValue"` Pairs, separated by whitespaces
value_table = { "VAL_TABLE_" ~ table_name ~ table_value_description* ~ ";" }

table_name = @{ ident_ext }
table_value_description = { int ~ quoted_str }

/// Signal group: SIG_GROUP_ message_id group_name multiplexer_id : signal1 signal2 ... ;
signal_group = { "SIG_GROUP_" ~ message_id ~ group_name ~ multiplexer_id ~ ":" ~ signal_name* ~ ";" }
group_name = @{ ident }
multiplexer_id = @{ int }

/// Signal value type: SIG_VALTYPE_ message_id signal_name : value_type;
signal_value_type = { "SIG_VALTYPE_" ~ message_id ~ signal_name ~ ":" ~ int ~ ";" }

/// Message transmitter: BO_TX_BU_ message_id : transmitter1,transmitter2,... ;
bo_tx_bu = { "BO_TX_BU_" ~ message_id ~ ":" ~ (transmitter ~ ("," ~ transmitter)*)? ~ ";" }

/// Relative attribute definition: BA_DEF_REL_ object_type attribute_name attribute_type [min max];
///
/// Control Unit -- Environment Variable
/// ```text
/// BA_DEF_REL_ BU_EV_REL_  "ControlUnitEnvVarAttr" STRING ;
/// ```
///
/// Node -- Tx Message
/// ```text
/// BA_DEF_REL_ BU_BO_REL_  "attribute_name" STRING ;
/// ```
///
/// Node -- Mapped Rx Signal
/// ```text
/// BA_DEF_REL_ BU_SG_REL_  "attribute_name" STRING ;
/// ```
///
/// ```text
/// BA_DEF_ EV_  "RWEnvVar_wData_Val" INT 0 10;
/// BA_DEF_ EV_  "GlobalEnvVar_Val" HEX 256 320;
/// BA_DEF_ SG_  "SGEnumAttribute" ENUM  "Val0","Val1","Val2";
/// BA_DEF_ BU_  "BUIntAttribute" INT 0 100;
/// BA_DEF_ BO_  "BOStringAttribute" STRING ;
/// BA_DEF_  "FloatAttribute" FLOAT 0 50.5;
/// BA_DEF_REL_ BU_EV_REL_  "ControlUnitEnvVarAttr" STRING ;
/// BA_DEF_REL_ BU_BO_REL_  "attribute_name" STRING ;
/// BA_DEF_REL_ BU_SG_REL_  "attribute_name" STRING ;
/// ```
ba_def_rel = { "BA_DEF_REL_" ~ rel_object_type ~ attribute_name ~ attribute_type ~ ";" }

/// Relative attribute value: BA_REL_ attribute_name object_type object_name value;
ba_rel = { "BA_REL_" ~ attribute_name ~ rel_object_type ~ rel_object_data ~ ";" }

rel_object_type = { "BU_SG_REL_" | "BU_BO_REL_" | "BU_EV_REL_" }

rel_object_data = {
    (ident ~ signal_var ~ num_str_value)
    | (ident ~ env_var ~ num_str_value)
    | (ident ~ message_id ~ num_str_value)
}

/// Relative attribute default: BA_DEF_DEF_REL_ attribute_name default_value;
ba_def_def_rel = { "BA_DEF_DEF_REL_" ~ attribute_name ~ num_str_value ~ ";" }

/// Global attribute default: BA_DEF_DEF_ attribute_name default_value;
ba_def_def = { "BA_DEF_DEF_" ~ attribute_name ~ num_str_value ~ ";" }

/// Multiplexed signal value definition: SG_MUL_VAL_ <message_id> <signal_name> <multiplexer_name> <value_pairs>;
sg_mul_val = { "SG_MUL_VAL_" ~ message_id ~ signal_name ~ multiplexer_name ~ value_pair ~ ("," ~ value_pair)* ~ ";" }
value_pair = { uint ~ "-" ~ uint }
multiplexer_name = @{ ident }

/// Environment variable definition: EV_ variable_name : type [min|max] "unit" access_type access_node node_name1 node_name2;
///
/// ```text
/// environment_variables = {environment_variable}
/// environment_variable = 'EV_' env_var_name ':' env_var_type '[' mini-
/// mum '|' maximum ']' unit initial_value ev_id access_type
/// access_node {',' access_node } ';' ;
///
/// env_var_name = DBC_identifier ;
///
/// env_var_type = '0' | '1' | '2' ; (* 0=integer, 1=float, 2=string *)
///
/// minimum = double ;
/// maximum = double ;
///
/// initial_value = double ;
///
/// ev_id = unsigned_integer ; (* obsolete *)
///
/// access_type = 'DUMMY_NODE_VECTOR0' | 'DUMMY_NODE_VECTOR1' |
///     'DUMMY_NODE_VECTOR2' | 'DUMMY_NODE_VECTOR3' |
///     'DUMMY_NODE_VECTOR8000' | 'DUMMY_NODE_VECTOR8001' |
///     'DUMMY_NODE_VECTOR8002' | 'DUMMY_NODE_VECTOR8003'; (*
///     0=unrestricted, 1=read, 2=write, 3=readWrite, if the value be-
///     hind 'DUMMY_NODE_VECTOR' is OR-ed with 0x8000, the value type
///     is always string. *)
///
/// access_node = node_name | 'VECTOR__XXX' ;
/// ```
///
/// example:
///
/// ```text
/// EV_ UnrestrictedEnvVar: 0 [0|0] "Nm" 0 1 DUMMY_NODE_VECTOR8000  Node0;
/// EV_ RWEnvVar_wData: 0 [0|1234] "" 60 2 DUMMY_NODE_VECTOR3  Node2;
/// EV_ WriteOnlyEnvVar: 1 [0|1234] "" 60 3 DUMMY_NODE_VECTOR2  Node2;
/// ```
environment_variable = {
    env_var ~ ":" ~ env_var_type ~ min_max ~ unit ~ init_value ~ ev_id ~ access_type ~ node_name ~ ";"
}
env_var_type = _{
    env_var_type_int
    | env_var_type_float
    | env_var_type_string
}
env_var_type_int = @{ "0" }
env_var_type_float = @{ "1" }
env_var_type_string = @{ "2" }
init_value = @{ int }
ev_id = @{ int }
access_type = ${ "DUMMY_NODE_VECTOR" ~ uint }

/// Environment variables data section
///
/// ```text
/// environment_variables_data = environment_variable_data ;
/// environment_variable_data = 'ENVVAR_DATA_' env_var_name ':' data_size ';' ;
/// data_size = unsigned_integer ;
/// ```
///
/// example:
///
/// ```text
/// ENVVAR_DATA_ RWEnvVar_wData: 10;
/// ```
envvar_data = { "ENVVAR_DATA_" ~ env_var_name ~ ":" ~ data_size ~ ";" }
data_size = @{ uint }
